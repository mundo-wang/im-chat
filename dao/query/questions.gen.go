// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package query

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"im-chat/dao/model"
)

func newQuestions(db *gorm.DB, opts ...gen.DOOption) questions {
	_questions := questions{}

	_questions.questionsDo.UseDB(db, opts...)
	_questions.questionsDo.UseModel(&model.Questions{})

	tableName := _questions.questionsDo.TableName()
	_questions.ALL = field.NewAsterisk(tableName)
	_questions.ID = field.NewInt(tableName, "id")
	_questions.Title = field.NewString(tableName, "title")
	_questions.Type = field.NewInt(tableName, "type")
	_questions.Answer = field.NewString(tableName, "answer")
	_questions.Status = field.NewInt(tableName, "status")
	_questions.AgentCode = field.NewString(tableName, "agent_code")
	_questions.PositionID = field.NewInt(tableName, "position_id")
	_questions.SessionRefID = field.NewString(tableName, "session_ref_id")
	_questions.CreatedBy = field.NewString(tableName, "created_by")
	_questions.UpdatedBy = field.NewString(tableName, "updated_by")
	_questions.CreatedAt = field.NewTime(tableName, "created_at")
	_questions.UpdatedAt = field.NewTime(tableName, "updated_at")
	_questions.DeletedAt = field.NewField(tableName, "deleted_at")

	_questions.fillFieldMap()

	return _questions
}

type questions struct {
	questionsDo

	ALL          field.Asterisk
	ID           field.Int    // 主键ID
	Title        field.String // 题目内容
	Type         field.Int    // 题型（0=选择题，1=判断题）
	Answer       field.String // 正确答案
	Status       field.Int    // 题目状态（0=未发布，1=已发布）
	AgentCode    field.String // 智能体编码
	PositionID   field.Int    // 岗位名称
	SessionRefID field.String // 关联的生成题目批次ID
	CreatedBy    field.String // 创建人
	UpdatedBy    field.String // 修改人
	CreatedAt    field.Time   // 创建时间
	UpdatedAt    field.Time   // 更新时间
	DeletedAt    field.Field  // 逻辑删除标记

	fieldMap map[string]field.Expr
}

func (q questions) Table(newTableName string) *questions {
	q.questionsDo.UseTable(newTableName)
	return q.updateTableName(newTableName)
}

func (q questions) As(alias string) *questions {
	q.questionsDo.DO = *(q.questionsDo.As(alias).(*gen.DO))
	return q.updateTableName(alias)
}

func (q *questions) updateTableName(table string) *questions {
	q.ALL = field.NewAsterisk(table)
	q.ID = field.NewInt(table, "id")
	q.Title = field.NewString(table, "title")
	q.Type = field.NewInt(table, "type")
	q.Answer = field.NewString(table, "answer")
	q.Status = field.NewInt(table, "status")
	q.AgentCode = field.NewString(table, "agent_code")
	q.PositionID = field.NewInt(table, "position_id")
	q.SessionRefID = field.NewString(table, "session_ref_id")
	q.CreatedBy = field.NewString(table, "created_by")
	q.UpdatedBy = field.NewString(table, "updated_by")
	q.CreatedAt = field.NewTime(table, "created_at")
	q.UpdatedAt = field.NewTime(table, "updated_at")
	q.DeletedAt = field.NewField(table, "deleted_at")

	q.fillFieldMap()

	return q
}

func (q *questions) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := q.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (q *questions) fillFieldMap() {
	q.fieldMap = make(map[string]field.Expr, 13)
	q.fieldMap["id"] = q.ID
	q.fieldMap["title"] = q.Title
	q.fieldMap["type"] = q.Type
	q.fieldMap["answer"] = q.Answer
	q.fieldMap["status"] = q.Status
	q.fieldMap["agent_code"] = q.AgentCode
	q.fieldMap["position_id"] = q.PositionID
	q.fieldMap["session_ref_id"] = q.SessionRefID
	q.fieldMap["created_by"] = q.CreatedBy
	q.fieldMap["updated_by"] = q.UpdatedBy
	q.fieldMap["created_at"] = q.CreatedAt
	q.fieldMap["updated_at"] = q.UpdatedAt
	q.fieldMap["deleted_at"] = q.DeletedAt
}

func (q questions) clone(db *gorm.DB) questions {
	q.questionsDo.ReplaceConnPool(db.Statement.ConnPool)
	return q
}

func (q questions) replaceDB(db *gorm.DB) questions {
	q.questionsDo.ReplaceDB(db)
	return q
}

type questionsDo struct{ gen.DO }

type IQuestionsDo interface {
	gen.SubQuery
	Debug() IQuestionsDo
	WithContext(ctx context.Context) IQuestionsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IQuestionsDo
	WriteDB() IQuestionsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IQuestionsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IQuestionsDo
	Not(conds ...gen.Condition) IQuestionsDo
	Or(conds ...gen.Condition) IQuestionsDo
	Select(conds ...field.Expr) IQuestionsDo
	Where(conds ...gen.Condition) IQuestionsDo
	Order(conds ...field.Expr) IQuestionsDo
	Distinct(cols ...field.Expr) IQuestionsDo
	Omit(cols ...field.Expr) IQuestionsDo
	Join(table schema.Tabler, on ...field.Expr) IQuestionsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionsDo
	RightJoin(table schema.Tabler, on ...field.Expr) IQuestionsDo
	Group(cols ...field.Expr) IQuestionsDo
	Having(conds ...gen.Condition) IQuestionsDo
	Limit(limit int) IQuestionsDo
	Offset(offset int) IQuestionsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionsDo
	Unscoped() IQuestionsDo
	Create(values ...*model.Questions) error
	CreateInBatches(values []*model.Questions, batchSize int) error
	Save(values ...*model.Questions) error
	First() (*model.Questions, error)
	Take() (*model.Questions, error)
	Last() (*model.Questions, error)
	Find() ([]*model.Questions, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Questions, err error)
	FindInBatches(result *[]*model.Questions, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.Questions) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IQuestionsDo
	Assign(attrs ...field.AssignExpr) IQuestionsDo
	Joins(fields ...field.RelationField) IQuestionsDo
	Preload(fields ...field.RelationField) IQuestionsDo
	FirstOrInit() (*model.Questions, error)
	FirstOrCreate() (*model.Questions, error)
	FindByPage(offset int, limit int) (result []*model.Questions, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IQuestionsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (q questionsDo) Debug() IQuestionsDo {
	return q.withDO(q.DO.Debug())
}

func (q questionsDo) WithContext(ctx context.Context) IQuestionsDo {
	return q.withDO(q.DO.WithContext(ctx))
}

func (q questionsDo) ReadDB() IQuestionsDo {
	return q.Clauses(dbresolver.Read)
}

func (q questionsDo) WriteDB() IQuestionsDo {
	return q.Clauses(dbresolver.Write)
}

func (q questionsDo) Session(config *gorm.Session) IQuestionsDo {
	return q.withDO(q.DO.Session(config))
}

func (q questionsDo) Clauses(conds ...clause.Expression) IQuestionsDo {
	return q.withDO(q.DO.Clauses(conds...))
}

func (q questionsDo) Returning(value interface{}, columns ...string) IQuestionsDo {
	return q.withDO(q.DO.Returning(value, columns...))
}

func (q questionsDo) Not(conds ...gen.Condition) IQuestionsDo {
	return q.withDO(q.DO.Not(conds...))
}

func (q questionsDo) Or(conds ...gen.Condition) IQuestionsDo {
	return q.withDO(q.DO.Or(conds...))
}

func (q questionsDo) Select(conds ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Select(conds...))
}

func (q questionsDo) Where(conds ...gen.Condition) IQuestionsDo {
	return q.withDO(q.DO.Where(conds...))
}

func (q questionsDo) Order(conds ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Order(conds...))
}

func (q questionsDo) Distinct(cols ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Distinct(cols...))
}

func (q questionsDo) Omit(cols ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Omit(cols...))
}

func (q questionsDo) Join(table schema.Tabler, on ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Join(table, on...))
}

func (q questionsDo) LeftJoin(table schema.Tabler, on ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.LeftJoin(table, on...))
}

func (q questionsDo) RightJoin(table schema.Tabler, on ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.RightJoin(table, on...))
}

func (q questionsDo) Group(cols ...field.Expr) IQuestionsDo {
	return q.withDO(q.DO.Group(cols...))
}

func (q questionsDo) Having(conds ...gen.Condition) IQuestionsDo {
	return q.withDO(q.DO.Having(conds...))
}

func (q questionsDo) Limit(limit int) IQuestionsDo {
	return q.withDO(q.DO.Limit(limit))
}

func (q questionsDo) Offset(offset int) IQuestionsDo {
	return q.withDO(q.DO.Offset(offset))
}

func (q questionsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IQuestionsDo {
	return q.withDO(q.DO.Scopes(funcs...))
}

func (q questionsDo) Unscoped() IQuestionsDo {
	return q.withDO(q.DO.Unscoped())
}

func (q questionsDo) Create(values ...*model.Questions) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Create(values)
}

func (q questionsDo) CreateInBatches(values []*model.Questions, batchSize int) error {
	return q.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (q questionsDo) Save(values ...*model.Questions) error {
	if len(values) == 0 {
		return nil
	}
	return q.DO.Save(values)
}

func (q questionsDo) First() (*model.Questions, error) {
	if result, err := q.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.Questions), nil
	}
}

func (q questionsDo) Take() (*model.Questions, error) {
	if result, err := q.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.Questions), nil
	}
}

func (q questionsDo) Last() (*model.Questions, error) {
	if result, err := q.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.Questions), nil
	}
}

func (q questionsDo) Find() ([]*model.Questions, error) {
	result, err := q.DO.Find()
	return result.([]*model.Questions), err
}

func (q questionsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.Questions, err error) {
	buf := make([]*model.Questions, 0, batchSize)
	err = q.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (q questionsDo) FindInBatches(result *[]*model.Questions, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return q.DO.FindInBatches(result, batchSize, fc)
}

func (q questionsDo) Attrs(attrs ...field.AssignExpr) IQuestionsDo {
	return q.withDO(q.DO.Attrs(attrs...))
}

func (q questionsDo) Assign(attrs ...field.AssignExpr) IQuestionsDo {
	return q.withDO(q.DO.Assign(attrs...))
}

func (q questionsDo) Joins(fields ...field.RelationField) IQuestionsDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Joins(_f))
	}
	return &q
}

func (q questionsDo) Preload(fields ...field.RelationField) IQuestionsDo {
	for _, _f := range fields {
		q = *q.withDO(q.DO.Preload(_f))
	}
	return &q
}

func (q questionsDo) FirstOrInit() (*model.Questions, error) {
	if result, err := q.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.Questions), nil
	}
}

func (q questionsDo) FirstOrCreate() (*model.Questions, error) {
	if result, err := q.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.Questions), nil
	}
}

func (q questionsDo) FindByPage(offset int, limit int) (result []*model.Questions, count int64, err error) {
	result, err = q.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = q.Offset(-1).Limit(-1).Count()
	return
}

func (q questionsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = q.Count()
	if err != nil {
		return
	}

	err = q.Offset(offset).Limit(limit).Scan(result)
	return
}

func (q questionsDo) Scan(result interface{}) (err error) {
	return q.DO.Scan(result)
}

func (q questionsDo) Delete(models ...*model.Questions) (result gen.ResultInfo, err error) {
	return q.DO.Delete(models)
}

func (q *questionsDo) withDO(do gen.Dao) *questionsDo {
	q.DO = *do.(*gen.DO)
	return q
}
